<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>TotCircles Stable Build</title>
<style>
  html,body{margin:0;height:100%;background:#03040a;}
  canvas{display:block;width:100%;height:100%;cursor:grab;}
  #ui{
    position:fixed;top:10px;left:10px;z-index:10;
    display:flex;gap:8px;align-items:center;
    background:rgba(15,20,35,.6);
    border:1px solid rgba(120,140,255,.25);
    border-radius:10px;padding:8px 10px;backdrop-filter:blur(6px);
  }
  button{background:#12162a;color:#e9edff;border:1px solid #2a3765;
          border-radius:8px;padding:6px 10px;cursor:pointer;}
  button:hover{background:#1b2143;}
  label{color:#9cf;font-size:12px;margin:0 6px;}
</style>
</head>
<body>
<div id="ui">
  <button id="play">Play / Pause</button>
  <label>Top K <input id="topK" type="range" min="10" max="200" step="5" value="100"></label>
  <label>Bottom K <input id="botK" type="range" min="10" max="200" step="5" value="100"></label>
</div>
<canvas id="cv"></canvas>

<script>
const cv=document.getElementById("cv"),ctx=cv.getContext("2d");
function resize(){cv.width=innerWidth;cv.height=innerHeight;}
addEventListener("resize",resize);resize();

let nodes=[],fps=10,fetchTimer=null;
const norm=p=>({x:p.x??p.X??0,y:p.y??p.Y??0});
const baseY=()=>cv.height/4;
const spacing=160,scale=200;
const weightRadius=24,topRadius=14;

let dragging=null,dragY=null;

/* ---- fetch state ---- */
async function fetchState(){
  if(dragging!==null) return;
  try{
    const r=await fetch("/api/state");
    const d=await r.json();
    nodes=(d.nodes||[]).map(norm);
  }catch{}
}
setInterval(fetchState,1000/fps);

/* ---- draw ---- */
function draw(){
  ctx.fillStyle="rgba(3,4,10,1)";
  ctx.fillRect(0,0,cv.width,cv.height);
  if(nodes.length){
    const totalWidth=(nodes.length-1)*spacing;
    const offsetX=(cv.width-totalWidth)/2;
    for(let i=0;i<nodes.length;i++){
      const nx=offsetX+i*spacing;
      const nyTop=baseY();
      const drop=nodes[i].x*scale;
      const nyWeight=nyTop+drop;
      const isDrag=(dragging===i);
      const drawY=isDrag?dragY:nyWeight;

      // spring line
      ctx.strokeStyle="rgba(180,200,255,0.45)";
      ctx.lineWidth=2;
      ctx.beginPath();ctx.moveTo(nx,nyTop);ctx.lineTo(nx,drawY);ctx.stroke();

      // top anchor
      ctx.beginPath();
      ctx.arc(nx,nyTop,topRadius,0,Math.PI*2);
      ctx.fillStyle="#888";ctx.fill();ctx.strokeStyle="#fff";ctx.stroke();

      // weight
      const hue=(i/nodes.length)*360;
      ctx.beginPath();
      ctx.arc(nx,drawY,weightRadius,0,Math.PI*2);
      ctx.fillStyle=`hsl(${hue},100%,60%)`;
      ctx.fill();
      ctx.lineWidth=2;
      ctx.strokeStyle=isDrag?"#fff":"#aaa";
      ctx.stroke();
    }
  }
  requestAnimationFrame(draw);
}
draw();

/* ---- play/pause control ---- */
document.getElementById("play").onclick=()=>fetch("/api/control");

/* ---- drag logic ---- */
cv.addEventListener("mousedown",async e=>{
  const rect=cv.getBoundingClientRect();
  const mx=e.clientX-rect.left,my=e.clientY-rect.top;
  const totalWidth=(nodes.length-1)*spacing;
  const offsetX=(cv.width-totalWidth)/2;
  for(let i=0;i<nodes.length;i++){
    const nx=offsetX+i*spacing;
    const nyTop=baseY()+nodes[i].x*scale;
    if(Math.hypot(mx-nx,my-nyTop)<=weightRadius+5){
      dragging=i;dragY=nyTop;cv.style.cursor="grabbing";
      await fetch("/api/control"); // pause
      break;
    }
  }
});

cv.addEventListener("mousemove",e=>{
  if(dragging!==null){
    const rect=cv.getBoundingClientRect();
    dragY=e.clientY-rect.top;
  }
});

cv.addEventListener("mouseup",async e=>{
  if(dragging!==null){
    const rect=cv.getBoundingClientRect();
    const my=e.clientY-rect.top;
    const anchorY=baseY();
    const dy=my-anchorY;
    const displacement=dy/scale;
    await fetch(`/api/set/${dragging}`,{
      method:"POST",
      headers:{"Content-Type":"application/json"},
      body:JSON.stringify({x:displacement})
    });
    dragging=null;cv.style.cursor="grab";
    await fetch("/api/control"); // resume
  }
});
cv.addEventListener("mouseleave",()=>{dragging=null;cv.style.cursor="grab";});

/* ---- anchor sliders ---- */
function postAnchors(){
  const topK=+document.getElementById("topK").value;
  const botK=+document.getElementById("botK").value;
  fetch("/api/anchors",{
    method:"POST",
    headers:{"Content-Type":"application/json"},
    body:JSON.stringify({topK,botK})
  });
}
document.getElementById("topK").oninput=postAnchors;
document.getElementById("botK").oninput=postAnchors;
</script>
</body>
</html>
